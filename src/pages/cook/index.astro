---
import Layout from "@/layouts/Layout.astro";
import "@/pages/cook/index.scss";
import { recipe } from "./recipe";

---

<Layout>
  <div class="cookWrapper">
    <ol class="recipeLists">
      {
        recipe.map(({ title, explanation, img }, index) => (
          <li class="recipeLists__item" data-recipe-list={index} id={`recipe${index}`}>
            <h2>{}{index} {title}</h2>
            <div class="recipeLists__body">
              <img width="280" height="280" src={img} class="recipeLists__img" />
              <p class="recipeLists__explanation">{explanation}</p>
            </div>
          </li>
        ))
      }
    </ol>
    <div class="tableOfContentsWrapper">
      <div class="tableOfContents__fixed">
        <nav class="tableOfContents">
          <ol class="tableOfContents__list" data-indexs>
            {
              recipe.map(({ title }, index) => (
                <li class="tableOfContents__item">
                  <button
                    data-table-of-contents={index}
                    class="tableOfContents__button"
                    type="button"
                  >
                    {title}
                  </button>
                </li>
              ))
            }
          </ol>
        </nav>
      </div>
    </div>
  </div>
</Layout>

<script>
  import { recipe } from "./recipe";


  const initRecipe = () => {
    const tableOfContentsItems = [
      ...document.querySelectorAll("[data-table-of-contents]"),
    ];

    tableOfContentsItems.map((item, index) => {
      item.addEventListener("click", () => {
        const target = document.querySelector(`[data-recipe-list="${index}"]`);
        target?.scrollIntoView({ behavior: "smooth", block: "center" });
      });
    });


    const handleIntersection = (entries: IntersectionObserverEntry[]) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          activeIndex(entry.target);
        }
      });
    };

    const options = {
      root: null,
      rootMargin: "-50% 0px", // ビューポートの中心
    };

    const observer = new IntersectionObserver(handleIntersection, options);

    const recipeListsItems = [...document.querySelectorAll("[data-recipe-list]")];

    if (recipeListsItems.length === 0) return;

    recipeListsItems.map((item) => {
      observer.observe(item);
    });

    const activeIndex = (element: Element) => {
      // すでにアクティブになっている目次を選択
      const currentActiveIndex = document.querySelector(
        "[data-indexs] .active"
      );
      // すでにアクティブになっているものが0個の時（=null）以外は、activeクラスを除去
      if (currentActiveIndex !== null) {
        currentActiveIndex.classList.remove("active");
      }
      const indexNumber = (element as HTMLElement).dataset.recipeList;

      const newActiveIndex = document.querySelector(`[data-table-of-contents="${indexNumber}"]`);
      newActiveIndex?.classList.add("active");
    };



    const mql = window.matchMedia("(min-width: 768px)");

    function updateDisplayBasedOnWidth(e: MediaQueryList | MediaQueryListEvent) {
      if (e.matches) {
        tableOfContentsItems.forEach((item, index) => {
          item.textContent = recipe[index].title;
        });
      } else {
        tableOfContentsItems.forEach((item, index) => {
          item.textContent = String(index);
        });
      }
    }

    updateDisplayBasedOnWidth(mql); // 初期表示時の状態を適用
    mql.addEventListener("change", updateDisplayBasedOnWidth);
  };

  initRecipe();
</script>
