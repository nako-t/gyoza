---
import "@/components/header/index.scss";
import Gyoza from "@/components/gyoza/index.astro";
import { navItems } from "./navItems.ts";

// Cookieを使用して訪問履歴を確認
// const hasVisited = Astro.cookies.has("visited");
const hasVisited = false;
// 訪問済みでない場合はCookieを設定
if (!hasVisited) {
  Astro.cookies.set("visited", "true", {
    path: "/",
    maxAge: 60 * 60 * 24,
  });
}
---

<header class="header">
  {!hasVisited && <Gyoza />}
  <nav class="globalNavigation" data-global-navigation>
    <ul class="globalNavigation__inner" data-nav-items-container>
      {
        navItems.map((item) => (
          <li class="globalNavigation__item" data-nav-item>
            <a
              class="globalNavigation__link"
              href={item.href}
              data-nav-item-link
            >
              <span class="globalNavigation__link-text">{item.label}</span>
            </a>
          </li>
        ))
      }
    </ul>
    <div class="globalNavigation__cursor" data-nav-cursor></div>
  </nav>
  <button class="hamburgerButton" data-hamburger-button>
    <span class="hamburgerButton__bar"></span>
    <span class="hamburgerButton__bar"></span>
    <span class="hamburgerButton__bar"></span>
  </button>
</header>

<script>
  import { navItems } from "./navItems.ts";

  const initNavigation = () => {
    // 現在のパスを取得して、パスと一致するアイテムにカーソルを表示
    // ホバーしたら移動する
    // ホバーアウトしたら、元の位置に戻る
    const currentPath = window.location.pathname;
    console.log(currentPath);

    const navItemsContainer = document.querySelector(
      "[data-nav-items-container]"
    );
    const navItemElements = document.querySelectorAll("[data-nav-item]");
    const cursor = document.querySelector("[data-nav-cursor]");

    if (
      !navItemsContainer ||
      !navItemElements ||
      !cursor ||
      !(cursor instanceof HTMLElement)
    )
      return;

    const navItemsContainerRect = navItemsContainer.getBoundingClientRect();

    const updateHoverIndicator = (targetItem: Element) => {
      const targetRect = targetItem.getBoundingClientRect();
      const currentIndicatorRect = cursor.getBoundingClientRect();

      console.log("targetRect" + targetRect.left);
      console.log("currentIndicatorRect" + currentIndicatorRect.left);
      console.log("navItemsContainerRect" + navItemsContainerRect.left);

      const newX = targetRect.left - navItemsContainerRect.left;

      cursor.style.width = `${targetRect.width}px`;
      cursor.style.height = `${targetRect.height}px`;

      cursor.animate(
        [
          {
            transform: window
              .getComputedStyle(cursor)
              .getPropertyValue("transform"),
          },
          {
            transform: `translate(${newX}px)`,
          },
        ],
        {
          duration: 300,
          easing: "ease-in-out",
          fill: "forwards", // アニメーション終了後に最終状態を維持
        }
      );
    };

    navItemElements.forEach((item) => {
      // 現在のパスを取得して、パスと一致するアイテムにカーソルを表示
      const itemLinkElement = item.querySelector("[data-nav-item-link]");

      if (!(itemLinkElement instanceof HTMLAnchorElement) || !itemLinkElement)
        return;

      if (itemLinkElement.getAttribute("href") === currentPath) {
        const itemRect = item.getBoundingClientRect();
        cursor.style.width = `${itemRect.width}px`;
        cursor.style.height = `${itemRect.height}px`;

        const currentItemRect = item.getBoundingClientRect();
        const newX = currentItemRect.left - navItemsContainerRect.left;

        cursor.style.transform = `translate(${newX}px)`;
      }

      item.addEventListener("mouseenter", () => {
        updateHoverIndicator(item);
      });
    });

    navItemsContainer.addEventListener("mouseleave", () => {
        let newX = 0;

      navItemElements.forEach((item) => {
        // 現在のパスを取得して、パスと一致するアイテムにカーソルを表示
        const itemLinkElement = item.querySelector("[data-nav-item-link]");
        if (!(itemLinkElement instanceof HTMLAnchorElement) || !itemLinkElement)
          return;

        if (itemLinkElement.getAttribute("href") === currentPath) {
          const currentItemRect = item.getBoundingClientRect();
          newX = currentItemRect.left - navItemsContainerRect.left;
        }
      });

      cursor.animate(
        [
          {
            transform: window
              .getComputedStyle(cursor)
              .getPropertyValue("transform"),
          },
          {
            transform: `translate(${newX}px)`,
          },
        ],
        {
          duration: 300,
          easing: "ease-in-out",
          fill: "forwards", // アニメーション終了後に最終状態を維持
        }
      );
    });
  };

  const initHamburgerButton = () => {
    const hamburgerButton = document.querySelector("[data-hamburger-button]");
    if (!hamburgerButton) return;

    hamburgerButton.addEventListener("click", () => {
      const globalNavigation = document.querySelector(
        "[data-global-navigation]"
      );
      if (!globalNavigation) return;

      globalNavigation.classList.toggle("is-active");
      hamburgerButton.classList.toggle("is-open");
    });
  };

  initNavigation();
  initHamburgerButton();
</script>
